package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/lovely-eye/server/internal/auth"
	"github.com/lovely-eye/server/internal/graph/model"
	"github.com/lovely-eye/server/internal/models"
	"github.com/lovely-eye/server/internal/services"
)

func (r *dashboardStatsResolver) TopPages(ctx context.Context, obj *model.DashboardStats, paging model.PagingInput) (*model.PagedPageStats, error) {
	limit, offset := normalizePaging(paging)
	stats, total, err := r.AnalyticsService.GetTopPagesWithFilterPaged(ctx, obj.SiteID, obj.From, obj.To, limit, offset, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get top pages: %w", err)
	}

	items := make([]*model.PageStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.PageStats{
			Path:     stat.Path,
			Views:    stat.Views,
			Visitors: stat.Visitors,
		})
	}

	return &model.PagedPageStats{
		Items: items,
		Total: total,
	}, nil
}

func (r *dashboardStatsResolver) TopReferrers(ctx context.Context, obj *model.DashboardStats, paging model.PagingInput) (*model.PagedReferrerStats, error) {
	limit, offset := normalizePaging(paging)
	stats, total, err := r.AnalyticsService.GetTopReferrersWithFilterPaged(ctx, obj.SiteID, obj.From, obj.To, limit, offset, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get top referrers: %w", err)
	}

	items := make([]*model.ReferrerStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.ReferrerStats{
			Referrer: stat.Referrer,
			Visitors: stat.Visitors,
		})
	}

	return &model.PagedReferrerStats{
		Items: items,
		Total: total,
	}, nil
}

func (r *dashboardStatsResolver) Browsers(ctx context.Context, obj *model.DashboardStats, paging model.PagingInput) ([]*model.BrowserStats, error) {
	limit, offset := normalizePaging(paging)
	stats, err := r.AnalyticsService.GetBrowserStatsWithFilter(ctx, obj.SiteID, obj.From, obj.To, limit, offset, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get browser stats: %w", err)
	}

	items := make([]*model.BrowserStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.BrowserStats{
			Browser:  stat.Browser,
			Visitors: stat.Visitors,
		})
	}
	return items, nil
}

func (r *dashboardStatsResolver) Devices(ctx context.Context, obj *model.DashboardStats, paging model.PagingInput) (*model.PagedDeviceStats, error) {
	limit, offset := normalizePaging(paging)
	stats, total, totalVisitors, err := r.AnalyticsService.GetDeviceStatsWithFilterPaged(ctx, obj.SiteID, obj.From, obj.To, limit, offset, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get device stats: %w", err)
	}

	items := make([]*model.DeviceStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.DeviceStats{
			Device:   stat.Device,
			Visitors: stat.Visitors,
		})
	}

	return &model.PagedDeviceStats{
		Items:         items,
		Total:         total,
		TotalVisitors: totalVisitors,
	}, nil
}

func (r *dashboardStatsResolver) Countries(ctx context.Context, obj *model.DashboardStats, paging model.PagingInput) (*model.PagedCountryStats, error) {
	limit, offset := normalizePaging(paging)
	stats, total, totalVisitors, err := r.AnalyticsService.GetCountryStatsWithFilterPaged(ctx, obj.SiteID, obj.From, obj.To, limit, offset, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get country stats: %w", err)
	}

	items := make([]*model.CountryStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.CountryStats{
			Country:  stat.Country,
			Visitors: stat.Visitors,
		})
	}

	return &model.PagedCountryStats{
		Items:         items,
		Total:         total,
		TotalVisitors: totalVisitors,
	}, nil
}

func (r *dashboardStatsResolver) DailyStats(ctx context.Context, obj *model.DashboardStats, bucket *model.TimeBucket, limit *int, offset *int) ([]*model.DailyStats, error) {
	var selectedBucket services.TimeBucket
	switch bucketValue := bucketValueOrDefault(bucket); bucketValue {
	case model.TimeBucketHourly:
		selectedBucket = services.TimeBucketHourly
	case model.TimeBucketDaily:
		selectedBucket = services.TimeBucketDaily
	default:
		return nil, errors.New("invalid time bucket")
	}

	pointLimit := defaultDailyPoints
	if selectedBucket == services.TimeBucketHourly {
		pointLimit = defaultHourlyPoints
	}
	if limit != nil {
		pointLimit = clampLimit(*limit, maxTimeSeriesPoints)
	}

	stats, err := r.AnalyticsService.GetTimeSeriesStatsWithFilter(ctx, obj.SiteID, obj.From, obj.To, selectedBucket, pointLimit, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get time series stats: %w", err)
	}

	if pointLimit > 0 {
		reverseDailyStats(stats)
	}

	items := make([]*model.DailyStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.DailyStats{
			Date:      time.Unix(stat.DateBucket, 0),
			Visitors:  stat.Visitors,
			PageViews: stat.PageViews,
			Sessions:  stat.Sessions,
		})
	}

	offsetValue := 0
	if offset != nil {
		offsetValue = *offset
	}

	if offsetValue >= len(items) {
		return []*model.DailyStats{}, nil
	}

	if offsetValue > 0 {
		items = items[offsetValue:]
	}

	return items, nil
}

func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	user, tokens, err := r.AuthService.Register(ctx, auth.RegisterInput{
		Username: input.Username,
		Password: input.Password,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to register user: %w", err)
	}

	// Set auth cookies - tokens are in HttpOnly cookies, not response body
	// See: https://www.reddit.com/r/node/comments/1im7yj0/comment/mc0ylfd/
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.SetAuthCookies(w, tokens)
	}

	return &model.AuthPayload{
		User: &model.User{
			ID:        strconv.FormatInt(user.ID, 10),
			Username:  user.Username,
			Role:      user.Role,
			CreatedAt: time.Now(),
		},
	}, nil
}

func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, tokens, err := r.AuthService.Login(ctx, auth.LoginInput{
		Username: input.Username,
		Password: input.Password,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to login: %w", err)
	}

	// Set auth cookies - tokens are in HttpOnly cookies, not response body
	// See: https://www.reddit.com/r/node/comments/1im7yj0/comment/mc0ylfd/
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.SetAuthCookies(w, tokens)
	}

	return &model.AuthPayload{
		User: &model.User{
			ID:        strconv.FormatInt(user.ID, 10),
			Username:  user.Username,
			Role:      user.Role,
			CreatedAt: time.Now(),
		},
	}, nil
}

func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.ClearAuthCookies(w)
	}
	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.TokenPayload, error) {
	tokens, err := r.AuthService.RefreshTokens(ctx, refreshToken)
	if err != nil {
		return nil, fmt.Errorf("failed to refresh tokens: %w", err)
	}

	// Set auth cookies
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.SetAuthCookies(w, tokens)
	}

	return &model.TokenPayload{
		AccessToken:  tokens.AccessToken,
		RefreshToken: tokens.RefreshToken,
	}, nil
}

func (r *mutationResolver) CreateSite(ctx context.Context, input model.CreateSiteInput) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	site, err := r.SiteService.Create(ctx, services.CreateSiteInput{
		Domains: input.Domains,
		Name:    input.Name,
		UserID:  claims.UserID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create site: %w", err)
	}

	return buildGraphQLSite(site), nil
}

func (r *mutationResolver) UpdateSite(ctx context.Context, id string, input model.UpdateSiteInput) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	site, err := r.SiteService.Update(ctx, siteID, claims.UserID, services.UpdateSiteInput{
		Name:             input.Name,
		TrackCountry:     input.TrackCountry,
		Domains:          input.Domains,
		BlockedIPs:       input.BlockedIPs,
		BlockedCountries: input.BlockedCountries,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update site: %w", err)
	}
	_ = r.AnalyticsService.SyncGeoIPRequirement(ctx)

	return buildGraphQLSite(site), nil
}

func (r *mutationResolver) DeleteSite(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return false, errors.New("invalid site ID")
	}

	if err := r.SiteService.Delete(ctx, siteID, claims.UserID); err != nil {
		return false, fmt.Errorf("failed to delete site: %w", err)
	}

	return true, nil
}

func (r *mutationResolver) RegenerateSiteKey(ctx context.Context, id string) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	site, err := r.SiteService.RegeneratePublicKey(ctx, siteID, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to regenerate site key: %w", err)
	}

	return buildGraphQLSite(site), nil
}

func (r *mutationResolver) RefreshGeoIPDatabase(ctx context.Context) (*model.GeoIPStatus, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	status, _ := r.AnalyticsService.RefreshGeoIPDatabase(ctx)
	return convertToGraphQLGeoIPStatus(status), nil
}

func (r *mutationResolver) UpsertEventDefinition(ctx context.Context, siteID string, input model.EventDefinitionInput) (*model.EventDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	fields := make([]services.EventFieldInput, 0, len(input.Fields))
	for _, field := range input.Fields {
		fields = append(fields, services.EventFieldInput{
			Key:       field.Key,
			Type:      strings.ToLower(string(field.Type)),
			Required:  field.Required,
			MaxLength: field.MaxLength,
		})
	}

	definition, err := r.EventDefService.Upsert(ctx, id, services.EventDefinitionInput{
		Name:   input.Name,
		Fields: fields,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to upsert event definition: %w", err)
	}

	results := convertToGraphQLEventDefinitions([]*models.EventDefinition{definition})
	return results[0], nil
}

func (r *mutationResolver) DeleteEventDefinition(ctx context.Context, siteID string, name string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return false, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return false, fmt.Errorf("failed to get site: %w", err)
	}

	if err := r.EventDefService.Delete(ctx, id, name); err != nil {
		return false, fmt.Errorf("failed to delete event definition: %w", err)
	}

	return true, nil
}

func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, nil //nolint:nilnil // unauthenticated returns no user without error
	}

	user, err := r.AuthService.GetUserByID(ctx, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return &model.User{
		ID:        strconv.FormatInt(user.ID, 10),
		Username:  user.Username,
		Role:      user.Role,
		CreatedAt: time.Now(),
	}, nil
}

func (r *queryResolver) Sites(ctx context.Context, paging model.PagingInput) ([]*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	limit, offset := normalizePaging(paging)
	sites, err := r.SiteService.GetUserSites(ctx, claims.UserID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get sites: %w", err)
	}

	var result []*model.Site
	for _, site := range sites {
		result = append(result, buildGraphQLSite(site))
	}

	return result, nil
}

func (r *queryResolver) Site(ctx context.Context, id string) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	site, err := r.SiteService.GetByID(ctx, siteID, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	return buildGraphQLSite(site), nil
}

func (r *queryResolver) Dashboard(ctx context.Context, siteID string, dateRange *model.DateRangeInput, filter *model.FilterInput) (*model.DashboardStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	from, to := parseDateRangeInput(dateRange)

	var filterOpts services.DashboardFilter
	if filter != nil {
		if filter.Referrer != nil {
			referrers := make([]string, 0, len(filter.Referrer))
			for _, referrer := range filter.Referrer {
				if referrer == "(direct)" {
					referrer = ""
				}
				referrers = append(referrers, referrer)
			}
			filterOpts.Referrer = referrers
		}
		if filter.Device != nil {
			filterOpts.Device = filter.Device
		}
		if filter.Page != nil {
			filterOpts.Page = filter.Page
		}
		if filter.Country != nil {
			filterOpts.Country = filter.Country
		}
		if filter.EventName != nil {
			filterOpts.EventName = filter.EventName
		}
		if filter.EventPath != nil {
			filterOpts.EventPath = filter.EventPath
		}
	}

	stats, err := r.AnalyticsService.GetDashboardOverviewWithFilter(ctx, id, from, to, filterOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to get dashboard overview: %w", err)
	}

	return &model.DashboardStats{
		Visitors:    stats.Visitors,
		PageViews:   stats.PageViews,
		Sessions:    stats.Sessions,
		BounceRate:  stats.BounceRate,
		AvgDuration: stats.AvgDuration,
		SiteID:      id,
		From:        from,
		To:          to,
		Filter:      filterOpts,
	}, nil
}

func (r *queryResolver) Realtime(ctx context.Context, siteID string) (*model.RealtimeStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	visitors, err := r.AnalyticsService.GetRealtimeVisitors(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get realtime visitors: %w", err)
	}

	return &model.RealtimeStats{
		Visitors: visitors,
		SiteID:   id,
	}, nil
}

func (r *queryResolver) GeoIPStatus(ctx context.Context) (*model.GeoIPStatus, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	status := r.AnalyticsService.GeoIPStatus()
	return convertToGraphQLGeoIPStatus(status), nil
}

func (r *queryResolver) GeoIPCountries(ctx context.Context, search *string, paging model.PagingInput) ([]*model.GeoIPCountry, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	query := ""
	if search != nil {
		query = *search
	}

	countries, err := r.AnalyticsService.GeoIPCountries(query)
	if err != nil {
		return nil, fmt.Errorf("failed to get geoip countries: %w", err)
	}

	limit, offset := normalizePaging(paging)
	if offset >= len(countries) {
		return []*model.GeoIPCountry{}, nil
	}

	end := offset + limit
	if end > len(countries) {
		end = len(countries)
	}

	result := make([]*model.GeoIPCountry, 0, end-offset)
	for _, country := range countries[offset:end] {
		result = append(result, &model.GeoIPCountry{
			Code: country.Code,
			Name: country.Name,
		})
	}
	return result, nil
}

func (r *queryResolver) Events(ctx context.Context, siteID string, dateRange *model.DateRangeInput, filter *model.FilterInput, limit *int, offset *int) (*model.EventsResult, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	from, to := parseDateRangeInput(dateRange)

	lim := defaultEventsPage
	off := 0
	if limit != nil {
		lim = *limit
	}
	if offset != nil {
		off = *offset
	}
	lim = clampLimit(lim, maxPageSize)
	if off < 0 {
		off = 0
	}

	referrer, device, page, country, eventName, eventPath := parseFilterInput(filter)

	var events []*models.Event
	var total int
	if filter == nil || (len(referrer) == 0 && len(device) == 0 && len(page) == 0 && len(country) == 0 && len(eventName) == 0 && len(eventPath) == 0) {
		events, total, err = r.AnalyticsService.GetEventsWithTotal(ctx, id, from, to, lim, off)
	} else {
		events, total, err = r.AnalyticsService.GetEventsWithTotalAndFilter(ctx, id, from, to, referrer, device, page, country, eventName, eventPath, lim, off)
	}
	if err != nil {
		return nil, fmt.Errorf("failed to get events: %w", err)
	}

	return convertToGraphQLEvents(events, total), nil
}

func (r *queryResolver) EventCounts(ctx context.Context, siteID string, dateRange *model.DateRangeInput, filter *model.FilterInput, paging model.PagingInput) ([]*model.EventCount, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	from, to := parseDateRangeInput(dateRange)

	limit, offset := normalizePaging(paging)

	referrer, device, page, country, eventName, eventPath := parseFilterInput(filter)

	eventCounts, err := r.AnalyticsService.GetEventCounts(ctx, id, from, to, referrer, device, page, country, eventName, eventPath, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get event counts: %w", err)
	}

	result := make([]*model.EventCount, 0, len(eventCounts))
	for _, ec := range eventCounts {
		result = append(result, &model.EventCount{
			Event: convertToGraphQLEvent(ec.Event),
			Count: ec.Count,
		})
	}

	return result, nil
}

func (r *queryResolver) EventDefinitions(ctx context.Context, siteID string, paging model.PagingInput) ([]*model.EventDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	limit, offset := normalizePaging(paging)
	definitions, err := r.EventDefService.List(ctx, id, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to list event definitions: %w", err)
	}

	return convertToGraphQLEventDefinitions(definitions), nil
}

func (r *realtimeStatsResolver) ActivePages(ctx context.Context, obj *model.RealtimeStats, paging model.PagingInput) ([]*model.ActivePageStats, error) {
	limit, offset := normalizePaging(paging)
	activePages, err := r.AnalyticsService.GetActivePages(ctx, obj.SiteID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get active pages: %w", err)
	}

	pages := make([]*model.ActivePageStats, len(activePages))
	for i, page := range activePages {
		pages[i] = &model.ActivePageStats{
			Path:     page.Path,
			Visitors: page.Visitors,
		}
	}

	return pages, nil
}

func (r *Resolver) DashboardStats() DashboardStatsResolver { return &dashboardStatsResolver{r} }

func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

func (r *Resolver) RealtimeStats() RealtimeStatsResolver { return &realtimeStatsResolver{r} }

type dashboardStatsResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type realtimeStatsResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *userResolver) Sites(ctx context.Context, obj *model.User, paging model.PagingInput) ([]*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	userID, err := strconv.ParseInt(obj.ID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid user ID")
	}

	if claims.UserID != userID {
		return nil, errors.New("unauthorized")
	}

	limit, offset := normalizePagingWithMax(paging, maxSitesPageSize)
	sites, err := r.SiteService.GetUserSites(ctx, userID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get user sites: %w", err)
	}

	result := make([]*model.Site, 0, len(sites))
	for _, site := range sites {
		result = append(result, buildGraphQLSite(site))
	}

	return result, nil
}
func (r *Resolver) User() UserResolver { return &userResolver{r} }
type userResolver struct{ *Resolver }
*/
