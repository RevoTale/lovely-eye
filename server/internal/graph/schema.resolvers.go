package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"errors"
	"strconv"
	"time"

	"github.com/lovely-eye/server/internal/auth"
	"github.com/lovely-eye/server/internal/graph/model"
	"github.com/lovely-eye/server/internal/services"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	user, tokens, err := r.AuthService.Register(ctx, auth.RegisterInput{
		Username: input.Username,
		Password: input.Password,
	})
	if err != nil {
		return nil, err
	}

	// Set auth cookies - tokens are in HttpOnly cookies, not response body
	// See: https://www.reddit.com/r/node/comments/1im7yj0/comment/mc0ylfd/
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.SetAuthCookies(w, tokens)
	}

	return &model.AuthPayload{
		User: &model.User{
			ID:        strconv.FormatInt(user.ID, 10),
			Username:  user.Username,
			Role:      user.Role,
			CreatedAt: time.Now(),
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, tokens, err := r.AuthService.Login(ctx, auth.LoginInput{
		Username: input.Username,
		Password: input.Password,
	})
	if err != nil {
		return nil, err
	}

	// Set auth cookies - tokens are in HttpOnly cookies, not response body
	// See: https://www.reddit.com/r/node/comments/1im7yj0/comment/mc0ylfd/
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.SetAuthCookies(w, tokens)
	}

	return &model.AuthPayload{
		User: &model.User{
			ID:        strconv.FormatInt(user.ID, 10),
			Username:  user.Username,
			Role:      user.Role,
			CreatedAt: time.Now(),
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.ClearAuthCookies(w)
	}
	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.TokenPayload, error) {
	tokens, err := r.AuthService.RefreshTokens(ctx, refreshToken)
	if err != nil {
		return nil, err
	}

	// Set auth cookies
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.SetAuthCookies(w, tokens)
	}

	return &model.TokenPayload{
		AccessToken:  tokens.AccessToken,
		RefreshToken: tokens.RefreshToken,
	}, nil
}

// CreateSite is the resolver for the createSite field.
func (r *mutationResolver) CreateSite(ctx context.Context, input model.CreateSiteInput) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	site, err := r.SiteService.Create(ctx, services.CreateSiteInput{
		Domain: input.Domain,
		Name:   input.Name,
		UserID: claims.UserID,
	})
	if err != nil {
		return nil, err
	}

	return &model.Site{
		ID:        strconv.FormatInt(site.ID, 10),
		Domain:    site.Domain,
		Name:      site.Name,
		PublicKey: site.PublicKey,
		CreatedAt: site.CreatedAt,
	}, nil
}

// UpdateSite is the resolver for the updateSite field.
func (r *mutationResolver) UpdateSite(ctx context.Context, id string, input model.UpdateSiteInput) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	site, err := r.SiteService.Update(ctx, siteID, claims.UserID, input.Name)
	if err != nil {
		return nil, err
	}

	return &model.Site{
		ID:        strconv.FormatInt(site.ID, 10),
		Domain:    site.Domain,
		Name:      site.Name,
		PublicKey: site.PublicKey,
		CreatedAt: site.CreatedAt,
	}, nil
}

// DeleteSite is the resolver for the deleteSite field.
func (r *mutationResolver) DeleteSite(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return false, errors.New("invalid site ID")
	}

	if err := r.SiteService.Delete(ctx, siteID, claims.UserID); err != nil {
		return false, err
	}

	return true, nil
}

// RegenerateSiteKey is the resolver for the regenerateSiteKey field.
func (r *mutationResolver) RegenerateSiteKey(ctx context.Context, id string) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	site, err := r.SiteService.RegeneratePublicKey(ctx, siteID, claims.UserID)
	if err != nil {
		return nil, err
	}

	return &model.Site{
		ID:        strconv.FormatInt(site.ID, 10),
		Domain:    site.Domain,
		Name:      site.Name,
		PublicKey: site.PublicKey,
		CreatedAt: site.CreatedAt,
	}, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, nil
	}

	user, err := r.AuthService.GetUserByID(ctx, claims.UserID)
	if err != nil {
		return nil, err
	}

	return &model.User{
		ID:       strconv.FormatInt(user.ID, 10),
		Username: user.Username,
		Role:     user.Role,
		// Note: CreatedAt is not available from auth.User, would need to add to interface if needed
		CreatedAt: time.Now(),
	}, nil
}

// Sites is the resolver for the sites field.
func (r *queryResolver) Sites(ctx context.Context) ([]*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	sites, err := r.SiteService.GetUserSites(ctx, claims.UserID)
	if err != nil {
		return nil, err
	}

	var result []*model.Site
	for _, site := range sites {
		result = append(result, &model.Site{
			ID:        strconv.FormatInt(site.ID, 10),
			Domain:    site.Domain,
			Name:      site.Name,
			PublicKey: site.PublicKey,
			CreatedAt: site.CreatedAt,
		})
	}

	return result, nil
}

// Site is the resolver for the site field.
func (r *queryResolver) Site(ctx context.Context, id string) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	site, err := r.SiteService.GetByID(ctx, siteID, claims.UserID)
	if err != nil {
		return nil, err
	}

	return &model.Site{
		ID:        strconv.FormatInt(site.ID, 10),
		Domain:    site.Domain,
		Name:      site.Name,
		PublicKey: site.PublicKey,
		CreatedAt: site.CreatedAt,
	}, nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context, siteID string, dateRange *model.DateRangeInput, filter *model.FilterInput) (*model.DashboardStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	// Verify ownership
	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, err
	}

	// Parse date range
	from, to := parseDateRangeInput(dateRange)

	// Parse filters
	var filterOpts services.DashboardFilter
	if filter != nil {
		if filter.Referrer != nil {
			// Normalize "(direct)" display value to empty string for DB filtering
			referrer := *filter.Referrer
			if referrer == "(direct)" {
				referrer = ""
			}
			filterOpts.Referrer = &referrer
		}
		if filter.Device != nil {
			filterOpts.Device = filter.Device
		}
		if filter.Page != nil {
			filterOpts.Page = filter.Page
		}
	}

	stats, err := r.AnalyticsService.GetDashboardStatsWithFilter(ctx, id, from, to, filterOpts)
	if err != nil {
		return nil, err
	}

	return convertToGraphQLStats(stats), nil
}

// Realtime is the resolver for the realtime field.
func (r *queryResolver) Realtime(ctx context.Context, siteID string) (*model.RealtimeStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	// Verify ownership
	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, err
	}

	visitors, err := r.AnalyticsService.GetRealtimeVisitors(ctx, id)
	if err != nil {
		return nil, err
	}

	return &model.RealtimeStats{
		Visitors: visitors,
		SiteID:   id,
	}, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, siteID string, dateRange *model.DateRangeInput, limit *int, offset *int) (*model.EventsResult, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	// Verify ownership
	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, err
	}

	// Parse date range
	from, to := parseDateRangeInput(dateRange)

	// Default pagination
	lim := 50
	off := 0
	if limit != nil {
		lim = *limit
	}
	if offset != nil {
		off = *offset
	}

	events, total, err := r.AnalyticsService.GetEventsWithTotal(ctx, id, from, to, lim, off)
	if err != nil {
		return nil, err
	}

	return convertToGraphQLEvents(events, total), nil
}

// ActivePages is the resolver for the activePages field.
func (r *realtimeStatsResolver) ActivePages(ctx context.Context, obj *model.RealtimeStats) ([]*model.ActivePageStats, error) {
	activePages, err := r.AnalyticsService.GetActivePages(ctx, obj.SiteID)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	pages := make([]*model.ActivePageStats, len(activePages))
	for i, page := range activePages {
		pages[i] = &model.ActivePageStats{
			Path:     page.Path,
			Visitors: page.Visitors,
		}
	}

	return pages, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// RealtimeStats returns RealtimeStatsResolver implementation.
func (r *Resolver) RealtimeStats() RealtimeStatsResolver { return &realtimeStatsResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type realtimeStatsResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *authPayloadResolver) AccessToken(ctx context.Context, obj *model.AuthPayload) (string, error) {
	panic(fmt.Errorf("not implemented: AccessToken - accessToken"))
}
func (r *Resolver) AuthPayload() AuthPayloadResolver { return &authPayloadResolver{r} }
type authPayloadResolver struct{ *Resolver }
*/
