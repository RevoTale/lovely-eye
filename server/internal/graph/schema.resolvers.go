package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/lovely-eye/server/internal/auth"
	"github.com/lovely-eye/server/internal/graph/model"
	"github.com/lovely-eye/server/internal/models"
	"github.com/lovely-eye/server/internal/services"
)

// TopPages is the resolver for the topPages field.
func (r *dashboardStatsResolver) TopPages(ctx context.Context, obj *model.DashboardStats, paging model.PagingInput) (*model.PagedPageStats, error) {
	limit, offset := normalizePaging(paging)
	stats, total, err := r.AnalyticsService.GetTopPagesWithFilterPaged(ctx, obj.SiteID, obj.From, obj.To, limit, offset, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get top pages: %w", err)
	}

	items := make([]*model.PageStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.PageStats{
			Path:     stat.Path,
			Views:    stat.Views,
			Visitors: stat.Visitors,
		})
	}

	return &model.PagedPageStats{
		Items: items,
		Total: total,
	}, nil
}

// TopReferrers is the resolver for the topReferrers field.
func (r *dashboardStatsResolver) TopReferrers(ctx context.Context, obj *model.DashboardStats, paging model.PagingInput) (*model.PagedReferrerStats, error) {
	limit, offset := normalizePaging(paging)
	stats, total, err := r.AnalyticsService.GetTopReferrersWithFilterPaged(ctx, obj.SiteID, obj.From, obj.To, limit, offset, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get top referrers: %w", err)
	}

	items := make([]*model.ReferrerStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.ReferrerStats{
			Referrer: stat.Referrer,
			Visitors: stat.Visitors,
		})
	}

	return &model.PagedReferrerStats{
		Items: items,
		Total: total,
	}, nil
}

// Browsers is the resolver for the browsers field.
func (r *dashboardStatsResolver) Browsers(ctx context.Context, obj *model.DashboardStats) ([]*model.BrowserStats, error) {
	stats, err := r.AnalyticsService.GetBrowserStatsWithFilter(ctx, obj.SiteID, obj.From, obj.To, 10, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get browser stats: %w", err)
	}

	items := make([]*model.BrowserStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.BrowserStats{
			Browser:  stat.Browser,
			Visitors: stat.Visitors,
		})
	}
	return items, nil
}

// Devices is the resolver for the devices field.
func (r *dashboardStatsResolver) Devices(ctx context.Context, obj *model.DashboardStats, paging model.PagingInput) (*model.PagedDeviceStats, error) {
	limit, offset := normalizePaging(paging)
	stats, total, totalVisitors, err := r.AnalyticsService.GetDeviceStatsWithFilterPaged(ctx, obj.SiteID, obj.From, obj.To, limit, offset, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get device stats: %w", err)
	}

	items := make([]*model.DeviceStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.DeviceStats{
			Device:   stat.Device,
			Visitors: stat.Visitors,
		})
	}

	return &model.PagedDeviceStats{
		Items:         items,
		Total:         total,
		TotalVisitors: totalVisitors,
	}, nil
}

// Countries is the resolver for the countries field.
func (r *dashboardStatsResolver) Countries(ctx context.Context, obj *model.DashboardStats, paging model.PagingInput) (*model.PagedCountryStats, error) {
	limit, offset := normalizePaging(paging)
	stats, total, totalVisitors, err := r.AnalyticsService.GetCountryStatsWithFilterPaged(ctx, obj.SiteID, obj.From, obj.To, limit, offset, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get country stats: %w", err)
	}

	items := make([]*model.CountryStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.CountryStats{
			Country:  stat.Country,
			Visitors: stat.Visitors,
		})
	}

	return &model.PagedCountryStats{
		Items:         items,
		Total:         total,
		TotalVisitors: totalVisitors,
	}, nil
}

// DailyStats is the resolver for the dailyStats field.
func (r *dashboardStatsResolver) DailyStats(ctx context.Context, obj *model.DashboardStats, bucket *model.TimeBucket, limit *int) ([]*model.DailyStats, error) {
	var selectedBucket services.TimeBucket
	switch bucketValue := bucketValueOrDefault(bucket); bucketValue {
	case model.TimeBucketHourly:
		selectedBucket = services.TimeBucketHourly
	case model.TimeBucketDaily:
		selectedBucket = services.TimeBucketDaily
	default:
		return nil, errors.New("invalid time bucket")
	}

	pointLimit := defaultDailyPoints
	if selectedBucket == services.TimeBucketHourly {
		pointLimit = defaultHourlyPoints
	}
	if limit != nil {
		pointLimit = clampLimit(*limit, maxTimeSeriesPoints)
	}

	stats, err := r.AnalyticsService.GetTimeSeriesStatsWithFilter(ctx, obj.SiteID, obj.From, obj.To, selectedBucket, pointLimit, obj.Filter)
	if err != nil {
		return nil, fmt.Errorf("failed to get time series stats: %w", err)
	}

	if pointLimit > 0 {
		reverseDailyStats(stats)
	}

	items := make([]*model.DailyStats, 0, len(stats))
	for _, stat := range stats {
		items = append(items, &model.DailyStats{
			Date:      stat.Date,
			Visitors:  stat.Visitors,
			PageViews: stat.PageViews,
			Sessions:  stat.Sessions,
		})
	}

	return items, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegisterInput) (*model.AuthPayload, error) {
	user, tokens, err := r.AuthService.Register(ctx, auth.RegisterInput{
		Username: input.Username,
		Password: input.Password,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to register user: %w", err)
	}

	// Set auth cookies - tokens are in HttpOnly cookies, not response body
	// See: https://www.reddit.com/r/node/comments/1im7yj0/comment/mc0ylfd/
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.SetAuthCookies(w, tokens)
	}

	return &model.AuthPayload{
		User: &model.User{
			ID:        strconv.FormatInt(user.ID, 10),
			Username:  user.Username,
			Role:      user.Role,
			CreatedAt: time.Now(),
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, tokens, err := r.AuthService.Login(ctx, auth.LoginInput{
		Username: input.Username,
		Password: input.Password,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to login: %w", err)
	}

	// Set auth cookies - tokens are in HttpOnly cookies, not response body
	// See: https://www.reddit.com/r/node/comments/1im7yj0/comment/mc0ylfd/
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.SetAuthCookies(w, tokens)
	}

	return &model.AuthPayload{
		User: &model.User{
			ID:        strconv.FormatInt(user.ID, 10),
			Username:  user.Username,
			Role:      user.Role,
			CreatedAt: time.Now(),
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.ClearAuthCookies(w)
	}
	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, refreshToken string) (*model.TokenPayload, error) {
	tokens, err := r.AuthService.RefreshTokens(ctx, refreshToken)
	if err != nil {
		return nil, fmt.Errorf("failed to refresh tokens: %w", err)
	}

	// Set auth cookies
	if w := GetResponseWriter(ctx); w != nil {
		r.AuthService.SetAuthCookies(w, tokens)
	}

	return &model.TokenPayload{
		AccessToken:  tokens.AccessToken,
		RefreshToken: tokens.RefreshToken,
	}, nil
}

// CreateSite is the resolver for the createSite field.
func (r *mutationResolver) CreateSite(ctx context.Context, input model.CreateSiteInput) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	site, err := r.SiteService.Create(ctx, services.CreateSiteInput{
		Domains: input.Domains,
		Name:    input.Name,
		UserID:  claims.UserID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create site: %w", err)
	}

	return buildGraphQLSite(site), nil
}

// UpdateSite is the resolver for the updateSite field.
func (r *mutationResolver) UpdateSite(ctx context.Context, id string, input model.UpdateSiteInput) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	site, err := r.SiteService.Update(ctx, siteID, claims.UserID, services.UpdateSiteInput{
		Name:             input.Name,
		TrackCountry:     input.TrackCountry,
		Domains:          input.Domains,
		BlockedIPs:       input.BlockedIPs,
		BlockedCountries: input.BlockedCountries,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update site: %w", err)
	}
	_ = r.AnalyticsService.SyncGeoIPRequirement(ctx)

	return buildGraphQLSite(site), nil
}

// DeleteSite is the resolver for the deleteSite field.
func (r *mutationResolver) DeleteSite(ctx context.Context, id string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return false, errors.New("invalid site ID")
	}

	if err := r.SiteService.Delete(ctx, siteID, claims.UserID); err != nil {
		return false, fmt.Errorf("failed to delete site: %w", err)
	}

	return true, nil
}

// RegenerateSiteKey is the resolver for the regenerateSiteKey field.
func (r *mutationResolver) RegenerateSiteKey(ctx context.Context, id string) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	site, err := r.SiteService.RegeneratePublicKey(ctx, siteID, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to regenerate site key: %w", err)
	}

	return buildGraphQLSite(site), nil
}

// RefreshGeoIPDatabase is the resolver for the refreshGeoIPDatabase field.
func (r *mutationResolver) RefreshGeoIPDatabase(ctx context.Context) (*model.GeoIPStatus, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	status, _ := r.AnalyticsService.RefreshGeoIPDatabase(ctx)
	return convertToGraphQLGeoIPStatus(status), nil
}

// UpsertEventDefinition is the resolver for the upsertEventDefinition field.
func (r *mutationResolver) UpsertEventDefinition(ctx context.Context, siteID string, input model.EventDefinitionInput) (*model.EventDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	fields := make([]services.EventFieldInput, 0, len(input.Fields))
	for _, field := range input.Fields {
		fields = append(fields, services.EventFieldInput{
			Key:       field.Key,
			Type:      strings.ToLower(string(field.Type)),
			Required:  field.Required,
			MaxLength: field.MaxLength,
		})
	}

	definition, err := r.EventDefService.Upsert(ctx, id, services.EventDefinitionInput{
		Name:   input.Name,
		Fields: fields,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to upsert event definition: %w", err)
	}

	results := convertToGraphQLEventDefinitions([]*models.EventDefinition{definition})
	return results[0], nil
}

// DeleteEventDefinition is the resolver for the deleteEventDefinition field.
func (r *mutationResolver) DeleteEventDefinition(ctx context.Context, siteID string, name string) (bool, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return false, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return false, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return false, fmt.Errorf("failed to get site: %w", err)
	}

	if err := r.EventDefService.Delete(ctx, id, name); err != nil {
		return false, fmt.Errorf("failed to delete event definition: %w", err)
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, nil //nolint:nilnil // unauthenticated returns no user without error
	}

	user, err := r.AuthService.GetUserByID(ctx, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return &model.User{
		ID:        strconv.FormatInt(user.ID, 10),
		Username:  user.Username,
		Role:      user.Role,
		CreatedAt: time.Now(),
	}, nil
}

// Sites is the resolver for the sites field.
func (r *queryResolver) Sites(ctx context.Context) ([]*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	sites, err := r.SiteService.GetUserSites(ctx, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user sites: %w", err)
	}

	var result []*model.Site
	for _, site := range sites {
		result = append(result, buildGraphQLSite(site))
	}

	return result, nil
}

// Site is the resolver for the site field.
func (r *queryResolver) Site(ctx context.Context, id string) (*model.Site, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	siteID, err := strconv.ParseInt(id, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	site, err := r.SiteService.GetByID(ctx, siteID, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	return buildGraphQLSite(site), nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context, siteID string, dateRange *model.DateRangeInput, filter *model.FilterInput) (*model.DashboardStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	// Verify ownership
	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	// Parse date range
	from, to := parseDateRangeInput(dateRange)

	// Parse filters
	var filterOpts services.DashboardFilter
	if filter != nil {
		if filter.Referrer != nil {
			referrers := make([]string, 0, len(filter.Referrer))
			for _, referrer := range filter.Referrer {
				if referrer == "(direct)" {
					referrer = ""
				}
				referrers = append(referrers, referrer)
			}
			filterOpts.Referrer = referrers
		}
		if filter.Device != nil {
			filterOpts.Device = filter.Device
		}
		if filter.Page != nil {
			filterOpts.Page = filter.Page
		}
		if filter.Country != nil {
			filterOpts.Country = filter.Country
		}
	}

	stats, err := r.AnalyticsService.GetDashboardOverviewWithFilter(ctx, id, from, to, filterOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to get dashboard overview: %w", err)
	}

	return &model.DashboardStats{
		Visitors:    stats.Visitors,
		PageViews:   stats.PageViews,
		Sessions:    stats.Sessions,
		BounceRate:  stats.BounceRate,
		AvgDuration: stats.AvgDuration,
		SiteID:      id,
		From:        from,
		To:          to,
		Filter:      filterOpts,
	}, nil
}

// Realtime is the resolver for the realtime field.
func (r *queryResolver) Realtime(ctx context.Context, siteID string) (*model.RealtimeStats, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	// Verify ownership
	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	visitors, err := r.AnalyticsService.GetRealtimeVisitors(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to get realtime visitors: %w", err)
	}

	return &model.RealtimeStats{
		Visitors: visitors,
		SiteID:   id,
	}, nil
}

// GeoIPStatus is the resolver for the geoIPStatus field.
func (r *queryResolver) GeoIPStatus(ctx context.Context) (*model.GeoIPStatus, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	status := r.AnalyticsService.GeoIPStatus()
	return convertToGraphQLGeoIPStatus(status), nil
}

// GeoIPCountries is the resolver for the geoIPCountries field.
func (r *queryResolver) GeoIPCountries(ctx context.Context, search *string) ([]*model.GeoIPCountry, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	query := ""
	if search != nil {
		query = *search
	}

	countries, err := r.AnalyticsService.GeoIPCountries(query)
	if err != nil {
		return nil, fmt.Errorf("failed to get geoip countries: %w", err)
	}

	result := make([]*model.GeoIPCountry, 0, len(countries))
	for _, country := range countries {
		result = append(result, &model.GeoIPCountry{
			Code: country.Code,
			Name: country.Name,
		})
	}
	return result, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, siteID string, dateRange *model.DateRangeInput, limit *int, offset *int) (*model.EventsResult, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	// Verify ownership
	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	// Parse date range
	from, to := parseDateRangeInput(dateRange)

	// Default pagination
	lim := 50
	off := 0
	if limit != nil {
		lim = *limit
	}
	if offset != nil {
		off = *offset
	}

	events, total, err := r.AnalyticsService.GetEventsWithTotal(ctx, id, from, to, lim, off)
	if err != nil {
		return nil, fmt.Errorf("failed to get events: %w", err)
	}

	return convertToGraphQLEvents(events, total), nil
}

// EventDefinitions is the resolver for the eventDefinitions field.
func (r *queryResolver) EventDefinitions(ctx context.Context, siteID string) ([]*model.EventDefinition, error) {
	claims := auth.GetUserFromContext(ctx)
	if claims == nil {
		return nil, errors.New("unauthorized")
	}

	id, err := strconv.ParseInt(siteID, 10, 64)
	if err != nil {
		return nil, errors.New("invalid site ID")
	}

	_, err = r.SiteService.GetByID(ctx, id, claims.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get site: %w", err)
	}

	definitions, err := r.EventDefService.List(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to list event definitions: %w", err)
	}

	return convertToGraphQLEventDefinitions(definitions), nil
}

// ActivePages is the resolver for the activePages field.
func (r *realtimeStatsResolver) ActivePages(ctx context.Context, obj *model.RealtimeStats) ([]*model.ActivePageStats, error) {
	activePages, err := r.AnalyticsService.GetActivePages(ctx, obj.SiteID)
	if err != nil {
		return nil, fmt.Errorf("failed to get active pages: %w", err)
	}

	// Convert to GraphQL model
	pages := make([]*model.ActivePageStats, len(activePages))
	for i, page := range activePages {
		pages[i] = &model.ActivePageStats{
			Path:     page.Path,
			Visitors: page.Visitors,
		}
	}

	return pages, nil
}

// DashboardStats returns DashboardStatsResolver implementation.
func (r *Resolver) DashboardStats() DashboardStatsResolver { return &dashboardStatsResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// RealtimeStats returns RealtimeStatsResolver implementation.
func (r *Resolver) RealtimeStats() RealtimeStatsResolver { return &realtimeStatsResolver{r} }

type dashboardStatsResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type realtimeStatsResolver struct{ *Resolver }
